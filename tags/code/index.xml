<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>code on aerth</title>
    <link>https://aerth.github.io/blog/tags/code/</link>
    <description>Recent content in code on aerth</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Feb 2016 06:57:03 +0000</lastBuildDate>
    
	<atom:link href="https://aerth.github.io/blog/tags/code/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>gnusocial command line</title>
      <link>https://aerth.github.io/blog/p/gnusocial-command-line/</link>
      <pubDate>Wed, 24 Feb 2016 06:57:03 +0000</pubDate>
      
      <guid>https://aerth.github.io/blog/p/gnusocial-command-line/</guid>
      <description>Go: qo-quitter &amp;ldquo;A GNU Social client for the future&amp;rdquo; So you are on your shell account, and want to read, post, follow new people, etc. go-quitter allows you to access your GNU Social node&amp;rsquo;s API from your terminal window.
Very work in progress. The entire code base is under complete transformation as I am learning Go. As of v0.0.8 the command go-quitter is separated from the go-quitter library. The library still may have things like &amp;ldquo;os.</description>
    </item>
    
    <item>
      <title>golang ports</title>
      <link>https://aerth.github.io/blog/p/golang-ports/</link>
      <pubDate>Fri, 12 Feb 2016 08:54:14 +0000</pubDate>
      
      <guid>https://aerth.github.io/blog/p/golang-ports/</guid>
      <description>So there are a bunch of command line programs out there that are common between unix varieties.
Some not as common as others.
You may recognize:
Here is a list of simple utilities, but in Golang!  package cat
import ( &amp;ldquo;github.com/yuya-takeyama/argf&amp;rdquo; &amp;ldquo;io&amp;rdquo; &amp;ldquo;os&amp;rdquo; )
func Cat(args []string) (int, error) { r, err := argf.From(args) if err != nil { return 2, err } _, err = io.Copy(os.Stdout, r) if err !</description>
    </item>
    
    <item>
      <title>easy cross compiling</title>
      <link>https://aerth.github.io/blog/p/easy-cross-compiling/</link>
      <pubDate>Thu, 11 Feb 2016 08:35:14 +0000</pubDate>
      
      <guid>https://aerth.github.io/blog/p/easy-cross-compiling/</guid>
      <description>Build for Mac OS X, Windows, Windows 64, linux-arm, netbsd-amd64, and a plethora of others. Modify to your needs, like anything else in the world.
Latest is inside https://github.com/aerth/cosgo (Makefile and scripts/pack.sh)
The following code outputs these binary files:
$ ./build-archs.sh Version10 $ ls Version10/ Version10_freebsd-386 Version10_netbsd-386 Version10_osx-amd64 Version10_freebsd-amd64 Version10_netbsd-amd64 Version10_windows-386.exe Version10_linux-386 Version10_openbsd-386 Version10_windows-amd64.exe Version10_linux-amd64 Version10_openbsd-amd64 Version10_linux-arm Version10_osx-386  #!/bin/sh version=&amp;quot;$1&amp;quot; mkdir $1 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 name=&amp;quot;../&amp;quot;&amp;quot;$version&amp;quot;&amp;quot;/&amp;quot;&amp;quot;$version&amp;quot;&amp;quot;_&amp;quot; # CGO_ENABLED=1 GOOS=darwin GOARCH=amd64 go build -o &amp;quot;$name&amp;quot;osx-amd64 GOOS=darwin GOARCH=386 go build -o &amp;quot;$name&amp;quot;osx-386 GOOS=freebsd GOARCH=amd64 go build -o &amp;quot;$name&amp;quot;freebsd-amd64 GOOS=freebsd GOARCH=386 go build -o &amp;quot;$name&amp;quot;freebsd-386 GOOS=netbsd GOARCH=amd64 go build -o &amp;quot;$name&amp;quot;netbsd-amd64 GOOS=netbsd GOARCH=386 go build -o &amp;quot;$name&amp;quot;netbsd-386 GOOS=openbsd GOARCH=amd64 go build -o &amp;quot;$name&amp;quot;openbsd-amd64 GOOS=openbsd GOARCH=386 go build -o &amp;quot;$name&amp;quot;openbsd-386 GOOS=linux GOARCH=arm go build -o &amp;quot;$name&amp;quot;linux-arm GOOS=linux GOARCH=amd64 go build -o &amp;quot;$name&amp;quot;linux-amd64 GOOS=linux GOARCH=386 go build -o &amp;quot;$name&amp;quot;linux-386 GOOS=windows GOARCH=amd64 go build -o &amp;quot;$name&amp;quot;windows-amd64.</description>
    </item>
    
    <item>
      <title>golang switch to logfile</title>
      <link>https://aerth.github.io/blog/p/golang-switch-to-logfile/</link>
      <pubDate>Thu, 11 Feb 2016 08:28:17 +0000</pubDate>
      
      <guid>https://aerth.github.io/blog/p/golang-switch-to-logfile/</guid>
      <description> func OpenLog(){ f, err := os.OpenFile(&amp;quot;./debug.log&amp;quot;, os.O_RDWR | os.O_CREATE | os.O_APPEND, 0666) if err != nil { log.Fatal(&amp;quot;error opening file: %v&amp;quot;, err) log.Fatal(&amp;quot;MANDRILL_KEY is Crucial.&amp;quot;) os.Exit(1) } log.SetOutput(f) }  This function can be placed in main() like so:
 log.Printf(&amp;quot;Starting Server on http://127.0.0.1:%s&amp;quot;, *port) log.Println(&amp;quot;Switching Logs to debug.log&amp;quot;) OpenLog() log.Println(&amp;quot;Server on&amp;quot;, *port)  </description>
    </item>
    
    <item>
      <title>golang random number generator</title>
      <link>https://aerth.github.io/blog/p/golang-random-number-generator/</link>
      <pubDate>Thu, 11 Feb 2016 08:27:02 +0000</pubDate>
      
      <guid>https://aerth.github.io/blog/p/golang-random-number-generator/</guid>
      <description> func init() { rand.Seed(time.Now().UnixNano()) } var runes = []rune(&amp;quot;____ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890123456789012345678901234567890&amp;quot;) func GenerateAPIKey(n int) string { b := make([]rune, n) for i := range b { b[i] = runes[rand.Intn(len(runes))] } return string(b) }  </description>
    </item>
    
    <item>
      <title>Qubes OS, a Xen based Desktop OS</title>
      <link>https://aerth.github.io/blog/p/qubes/</link>
      <pubDate>Tue, 09 Feb 2016 23:07:37 +0000</pubDate>
      
      <guid>https://aerth.github.io/blog/p/qubes/</guid>
      <description> Security by Isolation More info: https://www.qubes-os.org/ | http://qubesosmamapaxpa.onion/
 Not Linux Runs multiple instances of Linux Single User system dom0 stays offline One VM for this, One VM for that. Support for Fedora, Debian, and Whonix VMs  Give it a try! </description>
    </item>
    
    <item>
      <title>golang setup</title>
      <link>https://aerth.github.io/blog/p/golang-setup/</link>
      <pubDate>Mon, 08 Feb 2016 02:29:34 +0000</pubDate>
      
      <guid>https://aerth.github.io/blog/p/golang-setup/</guid>
      <description>Golang post-install Setting $GOPATH I use this in my ~/.zshrc or ~/.bashrc or system-wide in /etc/profile on a new user, or new computer. I don&amp;rsquo;t mess with it ever:
export GOPATH=$HOME/work # set gopath export PATH=$PATH:$GOPATH/bin # put go programs in your path  Now I test with something simple, and useful: sift, a fast grep alternative.
go get -v -u github.com/svent/sift testing echo $PATH | sift $GOPATH  New projects are in namespaces, cd $GOPATH/src/github.</description>
    </item>
    
  </channel>
</rss>